import os
import re
import secrets
import asyncio
from fastapi import FastAPI, HTTPException, Depends, Query
from pydantic import BaseModel
from vector import retriever
import pandas as pd
from dotenv import load_dotenv, find_dotenv
import google.generativeai as genai
from sqlalchemy.orm import Session
from sqlalchemy import desc
from database import init_db, get_db, Conversation
from migrate import run_migrations
from datetime import datetime, timedelta
from typing import List, Optional, Dict

# --- Session Management ---
# In-memory session storage: session_id -> {last_activity, previous_question, previous_answer, previous_conv_id, follow_up_question, recent_follow_ups}
session_storage: Dict[str, Dict] = {}
SESSION_TIMEOUT_MINUTES = 15

def generate_session_id() -> str:
    """Generate a short session ID (8 characters)"""
    return secrets.token_urlsafe(6)[:8]

def get_or_create_session(session_id: Optional[str]) -> str:
    """Get existing session or create new one"""
    if session_id and session_id in session_storage:
        session_storage[session_id]["last_activity"] = datetime.utcnow()
        return session_id
    new_session_id = generate_session_id()
    session_storage[new_session_id] = {
        "last_activity": datetime.utcnow(),
        "previous_question": None,
        "previous_answer": None,
        "previous_conv_id": None,
        "follow_up_question": None,
        "recent_follow_ups": []  # Track recent follow-ups to avoid repetition
    }
    return new_session_id

def cleanup_expired_sessions():
    """Remove sessions inactive for more than SESSION_TIMEOUT_MINUTES"""
    now = datetime.utcnow()
    expired_sessions = [
        sid for sid, data in session_storage.items()
        if (now - data["last_activity"]).total_seconds() > SESSION_TIMEOUT_MINUTES * 60
    ]
    for sid in expired_sessions:
        del session_storage[sid]
        print(f"Cleaned up expired session: {sid}")
    return len(expired_sessions)

async def periodic_cleanup():
    """Background task to clean up expired sessions"""
    while True:
        await asyncio.sleep(60)  # Check every minute
        cleaned = cleanup_expired_sessions()
        if cleaned > 0:
            print(f"Cleaned up {cleaned} expired session(s)")

# --- Models for API request and response ---
class AskRequest(BaseModel):
    """Request model expecting a 'question' field."""
    question: str
    session_id: Optional[str] = None  # Optional session ID for conversation continuity

class AskResponse(BaseModel):
    """Response model returning an 'answer' field."""
    answer: str
    follow_up_question: Optional[str] = None
    conversation_id: int
    session_id: str  # Session ID for next request

class ConversationResponse(BaseModel):
    """Response model for a single conversation."""
    id: int
    question: str
    answer: str
    follow_up_question: Optional[str] = None
    previous_conversation_id: Optional[int] = None
    created_at: datetime

    class Config:
        from_attributes = True

class ConversationsListResponse(BaseModel):
    """Response model for a list of conversations."""
    total: int
    conversations: List[ConversationResponse]

# --- Initialize FastAPI app ---
app = FastAPI(
    title="Nithub QA API",
    description="API to answer questions about Nithub using a curated Q&A knowledge base.",
)

# Initialize database on startup
@app.on_event("startup")
async def startup_event():
    try:
        # Run migrations first to ensure schema is up to date
        run_migrations()
        
        # Initialize database tables (creates tables if they don't exist)
        init_db()
        print("Database initialized successfully")
    except Exception as e:
        print(f"Database initialization error: {e}")
        raise  # Re-raise to prevent starting with broken database
    
    # Start background task for session cleanup
    asyncio.create_task(periodic_cleanup())
    print("Session cleanup task started")

# --- Configure Google Gemini ---
# Load .env from project root if present
_dotenv_path = find_dotenv(usecwd=True)
if _dotenv_path:
    load_dotenv(_dotenv_path)
else:
    load_dotenv()

api_key = os.getenv("GOOGLE_API_KEY")
if not api_key:
    raise RuntimeError("GOOGLE_API_KEY is not set. Please add it to .env or export it before starting the server.")
print(f"GOOGLE_API_KEY detected: {'*' * (len(api_key) - 4) + api_key[-4:]}\n")
genai.configure(api_key=api_key)
model_name = os.getenv("GEMINI_MODEL", "gemini-2.5-flash")
gemini_model = genai.GenerativeModel(model_name)

# Load CSV for follow-up question generation
csv_df = pd.read_csv("nithub_question.csv")

# --- API Endpoint ---
@app.post("/ask", response_model=AskResponse)
async def ask_question(request: AskRequest, db: Session = Depends(get_db)):
    """
    Accepts a question, retrieves relevant entries, and returns an answer generated by the LLM.
    Uses session management to automatically handle follow-up questions and context.
    Generates a follow-up question after answering.
    Saves the question and answer to the database.
    """
    original_question = request.question.strip()  # Store original for database
    question_text = original_question  # Processed question for answering
    
    # Get or create session
    session_id = get_or_create_session(request.session_id)
    session_data = session_storage[session_id]
    
    previous_context = ""
    is_related = False
    previous_conv_id = session_data.get("previous_conv_id")

    print(f"Received question: {original_question} (Session: {session_id})")

    # Check if user's response is an affirmative answer (Yes, Yeah, Sure, etc.)
    affirmative_responses = ["yes", "yeah", "yep", "sure", "okay", "ok", "yup", "absolutely", 
                           "definitely", "of course", "certainly", "indeed", "correct", "right"]
    
    is_affirmative = question_text.lower().strip(".,!?") in affirmative_responses
    
    # If user said "Yes" and there's a follow-up question in the session, extract the actual question
    if is_affirmative and session_data.get("follow_up_question"):
        follow_up_q = session_data["follow_up_question"]
        
        # Extract the actual question from "Would you like to know [question]?" format
        # Remove "Would you like to know" prefix and convert to direct question
        extracted_q = follow_up_q
        
        # Remove common prefixes
        prefixes_to_remove = [
            "would you like to know ",
            "would you like to know about ",
            "would you like to know the ",
            "would you like to know how to ",
            "would you like to know how ",
            "would you like to ",
        ]
        
        follow_up_lower = follow_up_q.lower().strip("?.")
        for prefix in prefixes_to_remove:
            if follow_up_lower.startswith(prefix):
                # Extract what comes after the prefix
                remaining = follow_up_q[len(prefix):].strip("?.")
                
                # Convert to a question if it's not already one
                remaining = remaining.strip()
                if remaining:
                    # Check if it already contains question words (what, how, when, where, why, who)
                    has_question_word = any(remaining.lower().startswith(qw + " ") or remaining.lower().startswith(qw) for qw in ["what", "how", "when", "where", "why", "who"])
                    
                    if has_question_word:
                        # Already a question format, just fix "us"/"you" -> "Nithub" and ensure proper capitalization
                        extracted_q = remaining
                        
                        # Fix pronouns - be careful with word boundaries
                        # Replace " us " (with spaces) -> " Nithub "
                        extracted_q = re.sub(r'\b us \b', ' Nithub ', extracted_q, flags=re.IGNORECASE)
                        # Replace " us" at end -> " Nithub"
                        extracted_q = re.sub(r'\b us\b', ' Nithub', extracted_q, flags=re.IGNORECASE)
                        # Replace "us " at start -> "Nithub "
                        extracted_q = re.sub(r'\bus \b', 'Nithub ', extracted_q, flags=re.IGNORECASE)
                        
                        # Replace " you " (with spaces) -> " Nithub "
                        extracted_q = re.sub(r'\b you \b', ' Nithub ', extracted_q, flags=re.IGNORECASE)
                        # Replace " you" at end -> " Nithub"
                        extracted_q = re.sub(r'\b you\b', ' Nithub', extracted_q, flags=re.IGNORECASE)
                        # Replace "you " at start -> "Nithub "
                        extracted_q = re.sub(r'\byou \b', 'Nithub ', extracted_q, flags=re.IGNORECASE)
                        
                        # Clean up extra spaces
                        extracted_q = re.sub(r' +', ' ', extracted_q).strip()
                        
                        # Capitalize first letter if needed
                        if extracted_q and not extracted_q[0].isupper():
                            extracted_q = extracted_q[0].upper() + extracted_q[1:]
                    elif remaining.lower().startswith("our "):
                        # "our programs" -> "What are our programs?"
                        topic = remaining[4:]  # Remove "our "
                        extracted_q = f"What are our {topic}?"
                    elif remaining.lower().startswith("the "):
                        # "the benefits of..." -> "What are the benefits of...?"
                        topic = remaining[4:]  # Remove "the "
                        extracted_q = f"What are the {topic}?"
                    elif remaining.lower().startswith("how to "):
                        # "how to sign up" -> "How do I sign up?"
                        action = remaining[7:]  # Remove "how to "
                        extracted_q = f"How do I {action}?"
                    elif remaining.lower().startswith("how "):
                        # "how we support" -> "How do you support startups?"
                        extracted_q = f"How do you {remaining[4:]}?"
                    else:
                        # Default: make it a "what is" or "tell me about" question
                        extracted_q = f"What is {remaining}?" if not any(word in remaining.lower() for word in ["about", "are", "is"]) else f"Tell me {remaining}?"
                
                if not extracted_q.endswith("?"):
                    extracted_q += "?"
                
                break
        
        # If no prefix matched, try to convert the follow-up to a direct question
        if extracted_q == follow_up_q:
            # Remove "Would you like to know" if present
            if "would you like to know" in follow_up_lower:
                # Extract the part after "would you like to know"
                parts = follow_up_q.lower().split("would you like to know", 1)
                if len(parts) > 1:
                    topic = parts[1].strip().strip("?.").strip()
                    
                    # Handle special cases based on topic content
                    if "what makes" in topic or "what makes us" in topic or "what makes you" in topic:
                        # "what makes us stand out" -> "What makes Nithub stand out?"
                        if "us" in topic:
                            topic = topic.replace("us", "Nithub").replace("you", "Nithub")
                        if "stand out" in topic or "different" in topic:
                            extracted_q = f"What makes Nithub stand out?" if "stand out" in topic else f"What makes Nithub different?"
                        else:
                            extracted_q = f"What makes Nithub {topic.replace('what makes ', '').replace('what makes us ', '').replace('what makes you ', '')}?"
                    elif topic.startswith("about "):
                        topic = topic[6:]
                        if topic.startswith("our "):
                            extracted_q = f"What are our {topic[4:]}?"
                        else:
                            extracted_q = f"Tell me about {topic}"
                    elif topic.startswith("the "):
                        topic = topic[4:]
                        if "benefits" in topic:
                            extracted_q = f"What are the {topic}?"
                        else:
                            extracted_q = f"Tell me about the {topic}"
                    elif topic.startswith("how to "):
                        topic = topic[7:]
                        extracted_q = f"How do I {topic}?"
                    elif topic.startswith("how "):
                        # "how we support" -> "How do you support startups?"
                        topic = topic[4:]
                        extracted_q = f"How do you {topic}?"
                    elif topic.startswith("our "):
                        extracted_q = f"Tell me about our {topic[4:]}"
                    else:
                        # Check if it's already a question format
                        if any(word in topic.lower() for word in ["what", "how", "when", "where", "why", "who"]):
                            extracted_q = topic.capitalize() if not topic[0].isupper() else topic
                        else:
                            extracted_q = f"Tell me about {topic}"
                    
                    if not extracted_q.endswith("?"):
                        extracted_q += "?"
        
        print(f"User answered affirmatively ('{original_question}'). Extracted question from follow-up: {extracted_q}")
        question_text = extracted_q  # Use extracted question for processing
        # This is definitely related to previous conversation
        is_related = True
    elif is_affirmative and not session_data.get("follow_up_question"):
        # User said yes but no follow-up question available - treat as asking for more info
        if session_data.get("previous_question"):
            question_text = f"Tell me more about {session_data['previous_question']}"
            is_related = True
            print(f"User said '{original_question}' but no follow-up. Expanding previous question: {question_text}")

    # Check if this is a follow-up to previous question in session (if not already determined)
    if session_data["previous_question"] and session_data["previous_answer"] and not is_related:
        # Check if the current question is related to the previous one in session
        relation_check_prompt = (
            "Determine if these two questions are related to each other. "
            "They are related if the second question is a follow-up, clarification, continuation, or builds on the first.\n\n"
            f"Previous Question: {session_data['previous_question']}\n"
            f"Previous Answer: {session_data['previous_answer']}\n"
            f"Previous Follow-up Question: {session_data.get('follow_up_question', 'None')}\n"
            f"Current Question: {question_text}\n\n"
            "Respond with only 'YES' if related, or 'NO' if not related:"
        )
        
        try:
            relation_response = gemini_model.generate_content(relation_check_prompt)
            relation_text = getattr(relation_response, "text", "").strip().upper()
            is_related = "YES" in relation_text
            
            if is_related:
                previous_context = f"Previous question: {session_data['previous_question']}\nPrevious answer: {session_data['previous_answer']}\n"
                if session_data.get("follow_up_question"):
                    previous_context += f"Previous follow-up suggestion: {session_data['follow_up_question']}\n"
                previous_context += "\n"
                print("Questions are related. Using previous context from session.")
            else:
                print("Questions are not related. Using current question only.")
        except Exception as e:
            print(f"Error checking question relation: {e}")
            # On error, assume related to be safe
            is_related = True
            previous_context = f"Previous question: {session_data['previous_question']}\nPrevious answer: {session_data['previous_answer']}\n\n"

    # 1. Retrieve relevant entries based on the processed question
    # If we're in a conversation context, also search for related topics
    search_query = question_text
    if is_related and session_data.get("previous_question"):
        # Enhance search query with previous context keywords
        search_query = f"{question_text} {session_data.get('previous_question', '')}"
    
    reviews = retriever.invoke(search_query)
    print(f"Retrieved reviews for query: {search_query}")

    # Convert retrieved Documents to a compact text context
    if isinstance(reviews, list):
        context_parts = []
        for doc in reviews:
            try:
                context_parts.append(str(getattr(doc, "page_content", doc)))
            except Exception:
                context_parts.append(str(doc))
        context_block = "\n\n".join(context_parts)
    else:
        context_block = str(reviews)

    # 2. Build the prompt and call Gemini
    prompt_text = (
        "You are an expert assistant answering questions about Nithub (an innovation hub in Lagos).\n\n"
        "INSTRUCTIONS:\n"
        "- Use the knowledge entries provided below to answer the question.\n"
        "- You can combine information from multiple entries to provide a complete answer.\n"
        "- When referring to Nithub, always use 'we' or 'our' (first person from Nithub's perspective), never 'they' or 'their'.\n"
        "- If the question asks about location/where, use any location information from the entries.\n"
        "- If the question asks 'why', provide relevant context from the entries that explains the reason.\n"
        "- Answer in a natural, helpful way based on the provided knowledge entries.\n"
        "- If the question cannot be answered from the provided entries at all, then respond with: 'I don't have that information in my knowledge base. Please contact Nithub directly for this information.'\n\n"
    )
    
    # Always include previous context if available (helps with conversation flow)
    if session_data.get("previous_question") and session_data.get("previous_answer"):
        if not previous_context:
            previous_context = f"Previous question: {session_data['previous_question']}\nPrevious answer: {session_data['previous_answer']}\n"
            if session_data.get("follow_up_question"):
                previous_context += f"Previous follow-up suggestion: {session_data['follow_up_question']}\n"
            previous_context += "\n"
        
        prompt_text += f"Previous conversation context:\n{previous_context}\n"
        if is_related:
            prompt_text += "The current question is a follow-up or continuation of the previous conversation. Use both the previous context and the knowledge entries below to provide a comprehensive answer that builds on what was discussed.\n\n"
        else:
            prompt_text += "Use the previous conversation context to provide consistent information. The knowledge entries below should be used to answer the current question.\n\n"
    
    prompt_text += (
        f"Knowledge entries from CSV:\n{context_block}\n\n"
        f"Question: {question_text}\n\n"
        "Answer based on the knowledge entries above, using 'we' or 'our' when referring to Nithub:"
    )

    try:
        gemini_response = gemini_model.generate_content(prompt_text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Gemini API error using model '{model_name}': {e}")
    result_text = getattr(gemini_response, "text", "") or str(gemini_response)

    # 3. Normalize whitespace to avoid \n in responses
    cleaned_answer = " ".join(result_text.split())

    # 4. Generate follow-up question - mix of related and random for variety
    # Find questions from the CSV, but add randomness to avoid always suggesting related topics
    follow_up_question = None
    try:
        import random
        
        question_lower = question_text.lower()
        selected_question = None
        
        # Get previously suggested follow-up questions from session to avoid repetition
        recent_follow_ups = session_data.get("recent_follow_ups", [])
        previous_topics = set()
        
        # Extract topics from recent follow-ups to avoid suggesting same topics
        for fu in recent_follow_ups:
            fu_lower = fu.lower()
            # Extract main topic (simple keyword extraction)
            if "program" in fu_lower:
                previous_topics.add("program")
            if "event" in fu_lower:
                previous_topics.add("event")
            if "incubation" in fu_lower or "startup" in fu_lower:
                previous_topics.add("startup")
            if "location" in fu_lower or "where" in fu_lower:
                previous_topics.add("location")
            if "training" in fu_lower or "course" in fu_lower:
                previous_topics.add("training")
        
        # Decide randomly whether to suggest related or random question (40% random, 60% related)
        use_random = random.random() < 0.4
        
        if use_random:
            # Pick a random question from CSV (not related to current question)
            print("Using random question selection for variety")
            if len(csv_df) > 0:
                available_questions = csv_df[
                    csv_df['Question'].str.lower() != question_lower
                ]['Question'].tolist()
                
                if available_questions:
                    # Filter out questions that are too similar to the current one
                    filtered = [q for q in available_questions 
                               if q.lower() not in question_lower and question_lower not in q.lower()]
                    
                    # Also try to avoid recent topics if possible
                    if previous_topics and filtered:
                        # Prefer questions about different topics
                        topic_diverse = [q for q in filtered 
                                        if not any(topic in q.lower() for topic in previous_topics)]
                        if topic_diverse:
                            selected_question = random.choice(topic_diverse)
                        else:
                            selected_question = random.choice(filtered)
                    elif filtered:
                        selected_question = random.choice(filtered)
                    else:
                        selected_question = random.choice(available_questions)
        else:
            # Try to find a related question (60% of the time)
            print("Using related question selection")
            related_docs = retriever.invoke(question_text)
            
            # Extract questions from the retrieved documents
            related_questions = []
            for doc in related_docs:
                if isinstance(doc, dict):
                    content = doc.get("page_content", "")
                else:
                    content = getattr(doc, "page_content", str(doc))
                
                # Extract question from "Q: [question]\nA: [answer]" format
                if content.startswith("Q:"):
                    parts = content.split("\nA:")
                    if len(parts) > 0:
                        q = parts[0].replace("Q:", "").strip()
                        # Remove quotes if present
                        if q.startswith('"') and q.endswith('"'):
                            q = q[1:-1]
                        related_questions.append(q)
            
            # Find a different question from retrieved ones
            # Try to avoid questions about topics we recently suggested
            for q in related_questions:
                q_lower = q.lower()
                # Skip if it's the same question or too similar
                if q_lower != question_lower and q_lower not in question_lower and question_lower not in q_lower:
                    # Prefer questions about different topics if we've been suggesting same topic
                    if previous_topics:
                        q_topics = [t for t in previous_topics if t in q_lower]
                        if not q_topics:  # This question is about a different topic - prefer it
                            selected_question = q
                            break
                    
                    # If no topic diversity preference or all related are same topic, just use first valid
                    if not selected_question:
                        selected_question = q
            
            # If we found a question, use it; otherwise continue to keyword matching
            if selected_question:
                pass  # Continue to use selected_question
            
            # If no good related question found from retrieval, search CSV for related topics
            if not selected_question and len(csv_df) > 0:
                # Extract meaningful keywords from the question (longer than 3 chars)
                keywords = [w.lower() for w in question_lower.split() if len(w) > 3]
                
                # Score questions by keyword matches, with bonus for topic diversity
                best_score = 0
                best_question = None
                diverse_candidates = []  # Questions about different topics
                
                for _, row in csv_df.iterrows():
                    csv_q = str(row['Question']).strip()
                    csv_q_lower = csv_q.lower()
                    
                    # Skip if identical
                    if csv_q_lower == question_lower:
                        continue
                    
                    # Skip if question is substring of CSV question or vice versa
                    if csv_q_lower in question_lower or question_lower in csv_q_lower:
                        continue
                    
                    # Count keyword matches
                    score = sum(1 for keyword in keywords if keyword in csv_q_lower)
                    
                    # Check if this question is about a different topic
                    q_topics = [t for t in previous_topics if t in csv_q_lower]
                    is_diverse = not q_topics if previous_topics else True
                    
                    # Prefer questions with some keyword overlap but not exact match
                    if score > 0:
                        if is_diverse:
                            diverse_candidates.append((csv_q, score))
                        if score > best_score:
                            best_score = score
                            best_question = csv_q
                
                # Prefer diverse topic questions if available
                if diverse_candidates:
                    # Sort by score and pick the best diverse one
                    diverse_candidates.sort(key=lambda x: x[1], reverse=True)
                    selected_question = diverse_candidates[0][0]
                elif best_question:
                    selected_question = best_question
        
        # Fallback: If still no question selected, pick random from CSV
        if not selected_question and len(csv_df) > 0:
            print("Fallback: Using random question")
            available_questions = csv_df[
                csv_df['Question'].str.lower() != question_lower
            ]['Question'].tolist()
            
            if available_questions:
                # Try to avoid questions that are too similar to current question
                filtered = [q for q in available_questions 
                           if q.lower() not in question_lower and question_lower not in q.lower()]
                if filtered:
                    selected_question = random.choice(filtered)
                else:
                    selected_question = random.choice(available_questions)
        
        # Generate follow-up question based on the selected question
        if selected_question:
            # Use LLM to convert the question into invitation format
            follow_up_prompt = (
                "Convert this question into an invitation format starting with 'Would you like to know'.\n\n"
                "The invitation should:\n"
                "- Start with 'Would you like to know' or 'Would you like to know about' or 'Would you like to know how to' or 'Would you like to know the benefits of'\n"
                "- Use varied formats (not always 'more about')\n"
                "- Use 'our' or 'we' when referring to Nithub\n"
                "- Be concise (one sentence ending with '?')\n"
                "- Be natural and inviting\n\n"
                f"Original question to convert: {selected_question}\n\n"
                "Examples of conversions:\n"
                "- 'What is Nithub?' → 'Would you like to know about our programs?'\n"
                "- 'Tell me about your incubation program' → 'Would you like to know the benefits of joining our incubation team?'\n"
                "- 'What training programs do you offer?' → 'Would you like to know the benefits of joining our programs?'\n"
                "- 'Where is Nithub located?' → 'Would you like to know how to sign up to our programs?'\n\n"
                "Generate ONLY the invitation question (no explanation):"
            )
            
            follow_up_response = gemini_model.generate_content(follow_up_prompt)
            follow_up_text = getattr(follow_up_response, "text", "").strip()
            follow_up_question = " ".join(follow_up_text.split())
            
            # Remove quotes if present
            if follow_up_question.startswith('"') and follow_up_question.endswith('"'):
                follow_up_question = follow_up_question[1:-1]
            if follow_up_question.startswith("'") and follow_up_question.endswith("'"):
                follow_up_question = follow_up_question[1:-1]
            
            # Ensure it starts with "Would you like to know"
            if not follow_up_question.lower().startswith("would you like to know"):
                # Try to extract if there's a question mark
                if "?" in follow_up_question:
                    parts = follow_up_question.split("?")
                    if parts:
                        potential = parts[0].strip()
                        if potential.lower().startswith("would you like"):
                            follow_up_question = potential + "?"
            
            # Ensure it ends with a question mark
            if not follow_up_question.endswith("?"):
                follow_up_question = follow_up_question.rstrip(".") + "?"
            
            print(f"Generated follow-up question from CSV: {follow_up_question} (based on: {selected_question})")
        else:
            print("No suitable related question found for follow-up")
            
    except Exception as e:
        print(f"Error generating follow-up question: {e}")
        import traceback
        traceback.print_exc()
        # Continue without follow-up if generation fails

    # 5. Save to database (store original question, not processed one)
    try:
        conversation = Conversation(
            question=original_question,  # Store the original user input
            answer=cleaned_answer,
            follow_up_question=follow_up_question,
            previous_conversation_id=previous_conv_id if is_related else None,
            created_at=datetime.utcnow()
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)
        print(f"Saved conversation ID: {conversation.id}")
    except Exception as e:
        print(f"Database save error: {e}")
        db.rollback()
        # Continue execution even if DB save fails
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

    # 6. Update session storage with current conversation data
    # Track recent follow-ups (keep last 5 to avoid repetition)
    recent_follow_ups = session_storage[session_id].get("recent_follow_ups", [])
    if follow_up_question:
        recent_follow_ups.append(follow_up_question)
        # Keep only last 5 follow-ups
        if len(recent_follow_ups) > 5:
            recent_follow_ups = recent_follow_ups[-5:]
    
    session_storage[session_id].update({
        "last_activity": datetime.utcnow(),
        "previous_question": original_question,  # Store original for session tracking
        "previous_answer": cleaned_answer,
        "previous_conv_id": conversation.id,
        "follow_up_question": follow_up_question,
        "recent_follow_ups": recent_follow_ups
    })

    # 7. Return the cleaned result with follow-up question and session ID
    return AskResponse(
        answer=cleaned_answer,
        follow_up_question=follow_up_question,
        conversation_id=conversation.id,
        session_id=session_id
    )

# --- Session info endpoint ---
@app.get("/session/{session_id}")
async def get_session_info(session_id: str):
    """
    Get information about a session.
    Returns session data if exists, or 404 if session expired/not found.
    """
    if session_id not in session_storage:
        raise HTTPException(status_code=404, detail="Session not found or expired")
    
    session_data = session_storage[session_id]
    time_since_activity = (datetime.utcnow() - session_data["last_activity"]).total_seconds()
    time_remaining = (SESSION_TIMEOUT_MINUTES * 60) - time_since_activity
    
    return {
        "session_id": session_id,
        "last_activity": session_data["last_activity"],
        "time_remaining_seconds": max(0, int(time_remaining)),
        "has_previous_conversation": session_data["previous_question"] is not None,
        "follow_up_question": session_data.get("follow_up_question")
    }

# --- Get conversations endpoint ---
@app.get("/conversations", response_model=ConversationsListResponse)
async def get_conversations(
    limit: int = Query(default=50, ge=1, le=100, description="Maximum number of conversations to return"),
    offset: int = Query(default=0, ge=0, description="Number of conversations to skip"),
    db: Session = Depends(get_db)
):
    """
    Retrieve stored conversations (questions and answers) from the database.
    
    - **limit**: Maximum number of conversations to return (1-100, default: 50)
    - **offset**: Number of conversations to skip for pagination (default: 0)
    
    Returns conversations ordered by most recent first.
    """
    try:
        # Get total count
        total = db.query(Conversation).count()
        
        # Get paginated conversations, ordered by most recent first
        conversations = db.query(Conversation)\
            .order_by(desc(Conversation.created_at))\
            .offset(offset)\
            .limit(limit)\
            .all()
        
        return ConversationsListResponse(
            total=total,
            conversations=[ConversationResponse.model_validate(conv) for conv in conversations]
        )
    except Exception as e:
        print(f"Error retrieving conversations: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving conversations: {str(e)}")

# --- Get single conversation by ID ---
@app.get("/conversations/{conversation_id}", response_model=ConversationResponse)
async def get_conversation(conversation_id: int, db: Session = Depends(get_db)):
    """
    Retrieve a single conversation by its ID.
    """
    conversation = db.query(Conversation).filter(Conversation.id == conversation_id).first()
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")
    return ConversationResponse.model_validate(conversation)

# --- (Optional) Add a root endpoint for basic check ---
@app.get("/")
async def root():
    return {"message": "Nithub QA API is running!"}
